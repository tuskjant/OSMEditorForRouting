# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EditorForRouting
                                 A QGIS plugin
 This plugin allow to edit OSM layer for routing purpouses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-07-18
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Gemma Riu
        email                : gemmariup@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QTimer
from qgis.PyQt.QtGui import QIcon, QStandardItemModel, QStandardItem
from qgis.PyQt.QtWidgets import QAction, QTableView
from qgis.core import QgsDataSourceUri, QgsVectorLayer, QgsProject, Qgis, QgsMapLayer, QgsWkbTypes
from qgis.gui import QgsMessageBar

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .osm_routing_editor_dialog import EditorForRoutingDialog
import os.path
# tool for select feature
from .select_feature_tool import SelectFeatureTool
# osrm feature data to edit features
from .osrm_feature_data import OsrmFeatureData
# database funcions
from .database_functions import *
# tool to create new line
from .add_line_functions import *
from .osrm_new_segment import NewSegment
from .data_handler import DataHandler

import time

class EditorForRouting:
    """QGIS Plugin Implementation."""
    segment_layer_name = "ways"
    tags_field_name = "tags"
    ways_style_file = "qgis_styles\ways_style.qml"
    ways_temp_style_file = "qgis_styles\ways_temp.qml"

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'EditorForRouting_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.canvas = iface.mapCanvas()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OSM Editor for Routing')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Load settings
        self.settings = QSettings('OSMRoutingEditor', 'OSMRE_settings')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('EditorForRouting', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/osm_routing_editor/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'OSM editor'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

        # create dialog and load settings
        self.dlg = EditorForRoutingDialog(routing_editor=self)
        self.load_settings()

        # Populate combobox values
        lst_road_type = [
            "primary",
            "secondary",
            "tertiary",
            "residential",
            "motorway",
            "trunk"
        ]
        self.dlg.comboBoxRoadType.addItems(lst_road_type)

        lst_direction = ["one-way", "both-ways"]
        self.dlg.comboBox_direction.addItems(lst_direction)

        # initialize table View
        self.tableView = None

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OSM Editor for Routing'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg.pushButtonAddLayers.clicked.connect(self.add_layer)
            self.dlg.pushButtonSelectTram.toggled.connect(self.handle_feature_selection)
            self.dlg.pushButtonActiva.clicked.connect(lambda: self.change_segment_access("allow_access"))
            self.dlg.pushButtonDesactiva.clicked.connect(lambda: self.change_segment_access("restrict_access"))
            self.dlg.pushButtonOneWay.clicked.connect(lambda: self.change_oneway("oneway"))
            self.dlg.pushButton_BothDirections.clicked.connect(lambda: self.change_oneway("bothways"))
            self.dlg.pushButtonMaxSpeed.clicked.connect(self.change_speed)
            self.dlg.pushButtonDirection.clicked.connect(self.change_direction)
            self.dlg.pushButtonUndoChanges.clicked.connect(self.undo_segment_changes)
            self.dlg.pushButton_addSegment.clicked.connect(self.add_segment)
            self.dlg.pushButtonToPbf.clicked.connect(self.convert_to_pbf)
            self.dlg.pushButtonLoadPbf.clicked.connect(self.load_pbf)
            self.dlg.pushButtonOsm2Pbf.clicked.connect(self.convert_osm_to_pbf)
            self.dlg.pushButtonPrepareData.clicked.connect(self.prepare_osrm_data)
            self.dlg.pushButtonRoadType.clicked.connect(self.ns_change_road_type)
            self.dlg.pushButton_direction.clicked.connect(self.ns_change_direction)
            self.dlg.pushButton_SpeedLimit.clicked.connect(self.ns_change_speed)
            self.dlg.pushButton_Reverse.clicked.connect(self.ns_reverse)
            self.dlg.pushButtonDelete.clicked.connect(self.ns_delete_segment)
            self.dlg.pushButton_create.clicked.connect(self.ns_create_segment_db)
            self.dlg.button_box.clicked.connect(self.close)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def load_settings(self):
        """ Method to load and set saved parameters (host, port, user, database, schema).
        """
        self.host = self.settings.value('host')
        if self.host is not None:
            self.dlg.lineEditHost.setText(self.host)
        self.port = self.settings.value('port')
        if self.port is not None:
            self.dlg.lineEditPort.setText(self.port)
        self.user = self.settings.value('user')
        if self.user is not None:
            self.dlg.lineEditUser.setText(self.user)
        self.database = self.settings.value('database')
        if self.database is not None:
            self.dlg.lineEditDB.setText(self.database)
        self.schema = self.settings.value('schema')
        if self.schema is not None:
            self.dlg.lineEditSchema.setText(self.schema)

    def add_layer(self):
        """ Method to load ways layer from database
        """
        # get connection parameters
        if not self.get_db_parameters():
            self.iface.messageBar().pushMessage(
                "Warning", "Missing connection parameters", Qgis.Warning, 10
            )
            return 

        # set connection
        uri = QgsDataSourceUri()
        uri.setConnection(self.host, self.port, self.database, self.user, self.password)

        # fetch ways layer
        where = "tags ? 'highway' or tags ? 'junction'"
        uri.setDataSource(self.schema, "ways", "linestring", where)
        self.ways_layer = QgsVectorLayer(uri.uri(), "ways", "postgres")

        # add ways layer
        if not self.ways_layer.isValid():
            self.iface.messageBar().pushMessage("Error", "Error when retriveing the layer.", Qgis.Warning, 10)
            return
        else:
            QgsProject.instance().addMapLayer(self.ways_layer)
            self.iface.setActiveLayer(self.ways_layer)
            self.iface.zoomToActiveLayer()
            # apply symbology
            qml_path = os.path.join(os.path.dirname(__file__), self.ways_style_file)
            self.ways_layer.loadNamedStyle(qml_path)
            self.ways_layer.triggerRepaint()

    def handle_feature_selection(self, checked):
        """Method to handle checkable button: checked select, unchecked unselect"""
        if checked:
            self.select_features()
        else:
            self.perform_cleanup()
            self.display_segments()

    def perform_cleanup(self):
        """Method to unselect all features """
        ways_layer = self.check_layer(self.segment_layer_name)
        if ways_layer is not None:
            ways_layer.removeSelection()
        self.display_segments()
        self.iface.actionIdentify().trigger() #activar la herramienta info

    def select_features(self):
        """Method to activate select feature tool for ways layer if layer is valid
        """
        # Get layer by name and check if exist
        ways_layer = self.check_layer(self.segment_layer_name)

        # Select features from ways layer
        if ways_layer is not None:
            self.tool = SelectFeatureTool(self.canvas, ways_layer)
            self.tool.feature_selected.connect(self.display_segments)
            self.canvas.setMapTool(self.tool)
        else:
            self.iface.messageBar().pushMessage("Error", "No layer available", Qgis.Warning, 10)

    def check_layer(self, layer_name):
        """Check if layer exist in type and format defined
        """
        # Get layer by name and check if exists
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if len(layers) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "Ways layer is not loaded", Qgis.Warning, 10
            )
            return
        ways_layer = layers[0]

        # Check layer type, geometry = linestring (2)
        if (
            ways_layer.type() != QgsMapLayer.VectorLayer
            or ways_layer.wkbType() != 2
        ):
            self.iface.messageBar().pushMessage(
                "Error", "Ways layer is not valid", Qgis.Warning, 10
            )
            return

        # Check layer attributes
        hasAttribute = False
        for field in ways_layer.fields():
            if field.name() == "tags":
                if field.type() == 8:  # hstore
                    hasAttribute = True
        if not hasAttribute:
            self.iface.messageBar().pushMessage(
                "Error",
                "Ways layer is not valid. Missing tags attribute",
                Qgis.Warning,
                10,
            )
            return
        return ways_layer

    def change_segment_access(self, option):
        """ Method to edit ways segment to allow or restrict segment access
        """
        ways_layer = self.check_layer(self.segment_layer_name)        
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return
        ways_layer.startEditing()

        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            osrm_feature.change_access(option)
            ways_layer.updateFeature(osrm_feature.feature)
        ways_layer.commitChanges()
        ways_layer.triggerRepaint()
        self.display_segments()

    def change_oneway(self, option):
        """Method to edit the segments of 'ways' to convert them to one-way or two-way circulation.
        """
        ways_layer = self.check_layer(self.segment_layer_name)        
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return
        ways_layer.startEditing()

        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            osrm_feature.change_one_way(option)
            ways_layer.updateFeature(osrm_feature.feature)
        ways_layer.commitChanges()
        ways_layer.triggerRepaint()
        self.display_segments()

    def change_speed(self):
        """Method to change speed to selected"""
        speed = self.dlg.spinBoxSpeed.value()
        ways_layer = self.check_layer(self.segment_layer_name)
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return
        ways_layer.startEditing()
        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            osrm_feature.change_speed(speed)
            ways_layer.updateFeature(osrm_feature.feature)
        ways_layer.commitChanges()
        ways_layer.triggerRepaint()
        self.display_segments()

    def change_direction(self):
        ways_layer = self.check_layer(self.segment_layer_name)

        # select features
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return

        # create connection
        parameters = self.get_db_parameters()
        if not parameters:
            return
        connection, cursor = connect_to_database(parameters)
        if connection is None or cursor is None:
            self.iface.messageBar().pushMessage(
                "Warning", "Can not connect to database", Qgis.Warning, 10
            )
            return

        # change direction of each feature
        for feature in selected_features:
            way_id = feature["id"]
            # Change direction
            reversed = change_line_direction(connection, cursor, way_id)
            if not reversed:
                self.iface.messageBar().pushMessage(
                    "Warning", f"Can not reverse {way_id} segment", Qgis.Warning, 10
                )

        # close connection
        closed = close_connection(connection, cursor)
        if not closed:
            self.iface.messageBar().pushMessage(
                "Warning", "An error occurred while closing database", Qgis.Warning, 10
            )

        # Updata layer data and display
        ways_layer.triggerRepaint()

        # mark feature as edited
        ways_layer = self.check_layer(self.segment_layer_name)
        selected_features = ways_layer.selectedFeatures()
        ways_layer.startEditing()
        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            osrm_feature.change_direction()
            ways_layer.updateFeature(osrm_feature.feature)
        ways_layer.commitChanges()
        ways_layer.triggerRepaint()
        self.display_segments()

        return

    def undo_segment_changes(self):
        # check if changing direction is needed
        self.undo_direction()

        ways_layer = self.check_layer(self.segment_layer_name)
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return

        # check if need to change direction
        ways_layer.startEditing()
        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            osrm_feature.change_edited("undo", None)
            ways_layer.updateFeature(osrm_feature.feature)
        ways_layer.commitChanges()
        ways_layer.triggerRepaint()
        self.display_segments()

    def undo_direction(self):
        # select features
        ways_layer = self.check_layer(self.segment_layer_name)
        selected_features = ways_layer.selectedFeatures()
        if len(selected_features) < 1:
            self.iface.messageBar().pushMessage(
                "Error", "There are no selected features", Qgis.Warning, 10
            )
            return

        # create connection
        parameters = self.get_db_parameters()
        if not parameters:
            return
        connection, cursor = connect_to_database(parameters)
        if connection is None or cursor is None:
            self.iface.messageBar().pushMessage(
                "Warning", "Can not connect to database", Qgis.Warning, 10
            )
            return

        # change direction if it is reversed
        for feature in selected_features:
            osrm_feature = OsrmFeatureData(feature, self.iface)
            current_direction = osrm_feature.extract_direction()
            if current_direction == "reversed":
                # reverse geometry
                way_id = feature["id"]
                change_line_direction(connection, cursor, way_id)

        # close connection
        closed = close_connection(connection, cursor)
        if not closed:
            self.iface.messageBar().pushMessage(
                "Warning", "An error occurred while closing database", Qgis.Warning, 10
            )

        # Updata layer data and display
        ways_layer.triggerRepaint()

    def display_segments(self):
        """Method to display attributes of selected segments in a table"""
        self.tableView = self.dlg.tableView
        model = QStandardItemModel()
        model.setHorizontalHeaderLabels(
            ["Id", "Name", "Access", "Oneway", "MaxSpeed", "Edited"]
        )

        # Get selected features and attributes
        ways_layer = self.check_layer(self.segment_layer_name)
        selected_features = ways_layer.selectedFeatures()
        table_data = []
        if selected_features:
            for feature in selected_features:
                osrm_feature = OsrmFeatureData(feature, self.iface)
                table_data.append(osrm_feature.get_table_row())

        for data_row in table_data:
            items = [QStandardItem(data) for data in data_row]
            model.appendRow(items)

        self.tableView.setModel(model)
        self.tableView.setColumnWidth(1, 200)

    def convert_to_pbf(self):
        """Method for exporting from database to pbf files"""
        pbf_folder = self.get_pbf_folder()
        osmosis_folder = self.get_osmosis_folder()
        if not pbf_folder or not osmosis_folder:
            return

        dbparameters = self.get_db_parameters()
        if not dbparameters:
            return

        osrm_data_handler = DataHandler(self.iface)
        osrm_data_handler.convert_to_pbf(dbparameters, pbf_folder, osmosis_folder)

    def convert_osm_to_pbf(self):
        pbf_folder = self.get_pbf_folder()
        osm_file = self.get_osm_file()
        osmosis_folder = self.get_osmosis_folder()
        if not pbf_folder or not osmosis_folder or not osm_file:
            return

        osrm_data_handler = DataHandler(self.iface)
        osrm_data_handler.convert_osm_to_pbf(osm_file, pbf_folder, osmosis_folder)

    def load_pbf(self):
        # Try to create new db using settings
        parameters = self.get_db_parameters()
        if not parameters:
            return

        osmosis_folder = self.get_osmosis_folder()
        if not osmosis_folder:
            return
        pbf_file = self.get_pbf_file()
        if not pbf_file:
            return

        osrm_data_handler = DataHandler(self.iface)
        osrm_data_handler.load_pbf(parameters,pbf_file,osmosis_folder)

    def prepare_osrm_data(self):
        input_pbf = self.get_pbf_file()
        osrm_docker_image = self.get_osrm_docker_image()
        docker_path = self.get_docker_path()
        if not input_pbf or not osrm_docker_image or not docker_path:
            return

        osrm_data_handler = DataHandler(self.iface)
        osrm_data_handler.prepare_osrm_data(input_pbf, docker_path, osrm_docker_image)

    def close(self):
        self.perform_cleanup()
        self.iface.messageBar().pushMessage(
            "Info", "Exited OSM Editor for Routing pluggin", Qgis.Info, 10
        )

    def get_db_parameters(self):

        # get user connection parameters
        self.host = self.dlg.lineEditHost.text()
        self.port = self.dlg.lineEditPort.text()
        self.user = self.dlg.lineEditUser.text()
        self.password = self.dlg.lineEditPassword.text()
        self.database = self.dlg.lineEditDB.text()
        self.schema = self.dlg.lineEditSchema.text()

        # save connection parameters to settings
        self.settings.setValue("host", self.host)
        self.settings.setValue("port", self.port)
        self.settings.setValue("user", self.user)
        self.settings.setValue("database", self.database)
        self.settings.setValue("schema", self.schema)

        # return parameters dict
        if self.host and self.port and self.user and self.password and self.database and self.schema:
            return {
                'dbname': self.database, 
                'user': self.user, 
                'password': self.password, 
                'host': self.host, 
                'port': self.port,
                'schema': self.schema
            }
        else:
            self.iface.messageBar().pushMessage(
                "Warning", "Missing connection parameters", Qgis.Warning, 10
            )
            return False

    def get_osmosis_folder(self):
        osmosis_folder = self.dlg.mQgsFileWidgetOsmosis.filePath()
        if osmosis_folder is None:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing osmossis folder in settings",
                Qgis.Warning,
                10,
            )
            return False
        return osmosis_folder

    def get_pbf_folder(self):
        pbf_folder = self.dlg.mQgsFileWidget_pbfFolder.filePath()
        if pbf_folder is None:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing pbf folder in settings",
                Qgis.Warning,
                10,
            )
            return False
        return pbf_folder

    def get_pbf_file(self):
        pbf_file = self.dlg.mQgsFileWidget_pbfFile.filePath()
        if pbf_file is None:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing input pbf file in settings",
                Qgis.Warning,
                10,
            )
            return False
        return pbf_file

    def get_osm_file(self):
        osm_file = self.dlg.mQgsFileWidget_osmfile.filePath()
        if osm_file is None:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing input osm file in settings",
                Qgis.Warning,
                10,
            )
            return False
        return osm_file

    def get_osrm_docker_image(self):
        osrm_docker_image = self.dlg.lineEdit_docker.text()
        if not osrm_docker_image:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing osrm docker image in settings",
                Qgis.Warning,
                10,
            )
            return False
        return osrm_docker_image

    def get_docker_path(self):
        docker_path = self.dlg.mQgsFileWidget_docker.filePath()
        if docker_path is None:
            self.iface.messageBar().pushMessage(
                "Warning",
                "Missing docker file",
                Qgis.Warning,
                10,
            )
            return False
        return docker_path

    def add_segment(self):
        # Create temporary layer
        self.temp_layer = create_temporary_line_layer()
        if self.temp_layer is None:
            self.iface.messageBar().pushMessage(
                "Warning", "Cannot create new segment", Qgis.Warning, 10
            )
            return

        # Connect signal to finish edition
        self.temp_layer.featureAdded.connect(self.feature_added)

        # Activate snapping options
        ways_layer = self.check_layer(self.segment_layer_name)
        if ways_layer is not None:
            enable_snapping_for_layer(ways_layer)

        # Start layer edition
        start_editing_layer(self.temp_layer)

        # Activate tool to add lines
        line_tool_activated = activate_add_line_tool(self.iface, self.temp_layer)
        if not line_tool_activated:
            self.iface.messageBar().pushMessage(
                "Warning", "Cannot activate segment edition", Qgis.Warning, 10
            )
            return

    def feature_added(self):
        self.temp_layer.featureAdded.disconnect() # disconnect signal
        finish_editing_layer(self.temp_layer)

        # apply symbology
        qml_path = os.path.join(os.path.dirname(__file__), self.ways_temp_style_file)
        if self.temp_layer.isValid():
            self.temp_layer.loadNamedStyle(qml_path)
            self.temp_layer.triggerRepaint()

        # Display new segment data in a table
        self.new_segment = NewSegment(self.temp_layer)
        if self.new_segment:
            data = self.new_segment.get_table_data()
            self.display_new_segments(data)

    def check_new_segment(self):
        if not hasattr(self, 'new_segment') or self.new_segment is None:
            self.iface.messageBar().pushMessage(
                "Warning", "You need to add a new segment first.", Qgis.Warning, 10
            )
            return False
        if not hasattr(self, 'temp_layer') or self.temp_layer is None or not self.temp_layer.isValid():
            self.iface.messageBar().pushMessage(
                "Warning", "You need to add a new segment first.", Qgis.Warning, 10
            )
            return False
        return True

    def display_new_segments(self, new_segment_data):
        """Method to display attributes of new created segments in a table"""

        # Create new table
        self.tableView = self.dlg.tableView_newSegment
        # Clear previous data
        self.clear_new_segment_table()

        model = QStandardItemModel()
        model.setHorizontalHeaderLabels(
            ["Id", "Road type", "Direction", "Max speed"]
        )

        items = [QStandardItem(data) for data in new_segment_data]
        model.appendRow(items)

        self.tableView.setModel(model)
        self.tableView.setColumnWidth(1, 200)

    def clear_new_segment_table(self):
        """Clear the data in the tableView"""
        if self.tableView is not None and self.tableView.model() is not None:
            model = self.tableView.model()
            if model.rowCount() > 0:
                model.removeRows(0, model.rowCount())

    def ns_change_road_type(self):
        if not self.check_new_segment():
            return
        type = str(self.dlg.comboBoxRoadType.currentText())
        self.new_segment.road_type = type
        self.display_new_segments(self.new_segment.get_table_data())

    def ns_change_direction(self):
        if not self.check_new_segment():
            return
        direction = str(self.dlg.comboBox_direction.currentText())
        self.new_segment.direction = direction
        self.display_new_segments(self.new_segment.get_table_data())

    def ns_change_speed(self):
        if not self.check_new_segment():
            return
        maxspeed = str(self.dlg.spinBoxSpeed_2.value())
        self.new_segment.max_speed = maxspeed
        self.display_new_segments(self.new_segment.get_table_data())

    def ns_reverse(self):
        if not self.check_new_segment():
            return
        reverse_line_direction_in_place(self.temp_layer)
        self.new_segment.geometry = NewSegment.extract_geometry(None, self.temp_layer)

    def ns_delete_segment(self):
        self.clear_new_segment_table()
        delete_temporary_line_layer()
        self.new_segment = None
        self.temp_layer = None
        self.canvas.refresh()

    def ns_create_segment_db(self):
        if not self.check_new_segment():
            return

        # create connection
        parameters = self.get_db_parameters()
        if not parameters:
            return
        connection, cursor = connect_to_database(parameters)
        if connection is None or cursor is None:
            self.iface.messageBar().pushMessage(
                "Warning", "Can not connect to database", Qgis.Warning, 10
            )
            return

        # get max ids for ways and nodes
        max_node_id = get_max_node_id(cursor)
        max_way_id = get_max_way_id(cursor)
        if not max_node_id or not max_way_id:
            self.iface.messageBar().pushMessage(
                "Warning", "Can not get ids from database", Qgis.Warning, 10
            )
            return
        
        # get osrm_user from db
        user_in_db = get_osrm_user_from_db(cursor)

        # create nodes, ways,way_nodes and user data
        nodes_bd = self.new_segment.create_nodes_bd(max_node_id)
        ways_bd = self.new_segment.create_ways_bd(max_node_id, max_way_id)
        way_nodes_bd = self.new_segment.create_way_nodes_bd(max_node_id, max_way_id)
        if user_in_db == "nouser":    #add user to database in case it not exist
            user_bd = self.new_segment.create_user_bd()
        else:
            user_bd = None
            
        if not nodes_bd or not ways_bd or not way_nodes_bd:
            return

        # insert ways - nodes data to database
        segment_added = add_segment(connection, cursor,nodes_bd, way_nodes_bd, ways_bd, user_bd)
        if not segment_added:
            self.iface.messageBar().pushMessage(
                "Warning", "Can not insert data into database", Qgis.Warning, 10
            )
            return

        # close connection
        close_connection(connection, cursor)

        # refresh screen and clean temporary data
        self.ns_delete_segment()
        ways_layer = self.check_layer(self.segment_layer_name)
        if ways_layer is not None:
            ways_layer.triggerRepaint()
        self.canvas.refresh()
